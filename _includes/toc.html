{%- comment %}
  输入: include.content (文章的HTML内容)
  输出: 一个支持动态层级的、两级嵌套的HTML <ul> 列表
  - 如果文章有 h2, 则目录为 h2 -> h3
  - 如果文章没有 h2 但有 h3, 则目录为 h3 -> h4
{%- endcomment %}

{%- assign toc_output = "" -%}
{%- assign heading_count = 0 -%}
{%- assign last_level = 0 -%}

{%- comment %} --- 步骤1: 动态确定顶层和嵌套层的标题级别 --- {% endcomment %}
{%- assign top_level_tag = 0 -%}
{%- if include.content contains '<h2' -%}
  {%- assign top_level_tag = 2 -%}
{%- elsif include.content contains '<h3' -%}
  {%- assign top_level_tag = 3 -%}
{%- endif -%}
{%- assign nested_level_tag = top_level_tag | plus: 1 -%}


{%- comment %} --- 步骤2: 如果找到了有效的起始标题级别，则开始生成TOC --- {% endcomment %}
{%- if top_level_tag > 0 -%}
  {%- assign content_parts = include.content | split: '<h' -%}

  {%- for part in content_parts -%}
    {%- if part contains 'id="' -%}
      {%- capture heading_level_str %}{{ part | slice: 0 }}{% endcapture -%}
      {%- assign current_level = heading_level_str | plus: 0 -%}

      {%- comment %} --- 只处理我们选定的两个级别的标题 --- {% endcomment %}
      {%- if current_level == top_level_tag or current_level == nested_level_tag -%}
        {%- assign heading_count = heading_count | plus: 1 -%}

        {%- comment %} --- 核心逻辑：根据层级变化关闭标签 --- {% endcomment %}
        {%- if last_level != 0 -%}
          {%- if current_level < last_level -%}
            {%- assign toc_output = toc_output | append: '</li></ul></li>' -%}
          {%- elsif current_level == last_level -%}
            {%- assign toc_output = toc_output | append: '</li>' -%}
          {%- endif -%}
        {%- endif -%}

        {%- comment %} --- 核心逻辑：根据层级变化打开标签 --- {% endcomment %}
        {%- if current_level > last_level -%}
          {%- assign toc_output = toc_output | append: '<ul class="list list--toc-nested">' -%}
        {%- endif -%}
        
        {%- comment %} --- 提取标题 ID 和文本 --- {% endcomment %}
        {%- assign id_parts = part | split: 'id="' -%}
        {%- assign id_and_rest = id_parts[1] | split: '"' -%}
        {%- assign heading_id = id_and_rest[0] -%}
        {%- assign text_parts = part | split: '</h' -%}
        {%- assign text_and_tags = text_parts[0] | split: '>' -%}
        {%- assign heading_text = text_and_tags[1] | strip_html -%}

        {%- comment %} --- 生成当前标题的 <li> 元素 --- {% endcomment %}
        {%- capture li_item -%}<li class="item item--toc-level-{{ current_level }}"><a href="#{{ heading_id }}">{{ heading_text }}</a>{%- endcapture -%}
        {%- assign toc_output = toc_output | append: li_item -%}

        {%- assign last_level = current_level -%}
      {%- endif -%}
    {%- endif -%}
  {%- endfor -%}

  {%- comment %} --- 循环结束后，关闭所有剩余的开放标签 --- {% endcomment %}
  {%- if last_level == nested_level_tag -%}
    {%- assign toc_output = toc_output | append: '</li></ul></li>' -%}
  {%- elsif last_level == top_level_tag -%}
    {%- assign toc_output = toc_output | append: '</li>' -%}
  {%- endif -%}
{%- endif -%}


{%- comment %} --- 最终输出完整的 nav 结构 --- {% endcomment %}
{%- if heading_count > 0 -%}
<nav class="nav nav--toc">
  <ul class="list list--toc">
    {{ toc_output }}
  </ul>
</nav>
{%- endif -%}