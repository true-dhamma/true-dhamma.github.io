{%- comment %}
  ============================================================================
  SHARED TOC LOGIC & STYLES
  This file provides all necessary CSS and JS for the Tocbot feature.
  It expects specific HTML containers to be present in the calling layout.
  ============================================================================
{%- endcomment %}

{%- assign show_toc_feature = false -%}
{%- if page.toc == true -%}
  {%- assign show_toc_feature = true -%}
{%- endif -%}

{% if show_toc_feature %}
<style>
  /* --- 基础样式 (移动端优先) --- */
  .content-toc-right-wrapper { display: none; }
  .toc-middle-container { display: none; margin: 2em 0; padding: 1.2em 1.5em; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f8f9fa; }

  /* --- TOCBOT 通用样式 --- */
  .toc-title { margin: 0 0 1em; font-size: 1.1em; font-weight: 600; color: #333; }
  .toc-middle-container .toc-title { margin-top: 0; }
  .toc-list { margin: 0; padding: 0; list-style: none; }
  .toc-list-item { margin-bottom: 5px; }
  .toc-list .toc-list { padding-left: 1.25em; }
  .toc-link { display: block; padding: 4px 10px; border-left: 2px solid #EEE; color: #777; font-size: 0.875em; line-height: 1.5; transition: all 0.2s ease-in-out; text-decoration: none !important; }
  .toc-link:hover { color: #333; border-left-color: #AAA; }
  .is-active-link { color: #007bff; font-weight: 600; border-left-color: #007bff; background-color: #f0f7ff; }

  /* --- 右侧TOC的Hover效果 --- */
  .content-toc-right-wrapper {
    opacity: 0.5;
    transition: opacity 0.1s ease-in-out;
  }
  .content-toc-right-wrapper:hover { opacity: 1; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.27.18/tocbot.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const mainContainer = document.querySelector('.main.container');
  const middleTocContainer = document.getElementById('toc-middle-container');
  const rightTocWrapper = document.querySelector('.content-toc-right-wrapper');
  const contentArea = document.querySelector('.js-toc-content');

  if (!contentArea || (!middleTocContainer && !rightTocWrapper)) { return; }

  const isDocLayout = mainContainer.classList.contains('layout-doc');
  const isPostLayout = mainContainer.classList.contains('layout-post');

  const DESKTOP_BREAKPOINT = isDocLayout ? 1200 : 1024;
  const pageHasAside = {{ page.aside | default: false }};
  const forceMiddleToc = isPostLayout && pageHasAside;

  // ... (unchanged logic for post layout) ...
  if (isPostLayout && middleTocContainer) {
    const pageTitle = contentArea.querySelector('h1');
    if (pageTitle) {
      let nextEl = pageTitle.nextElementSibling;
      if (nextEl && nextEl.classList.contains('post-meta')) { nextEl = nextEl.nextElementSibling; }
      if (nextEl && nextEl.id === 'toc-middle-container') { nextEl = nextEl.nextElementSibling; }
      if (nextEl && nextEl.tagName === 'BLOCKQUOTE') { nextEl.parentNode.insertBefore(middleTocContainer, nextEl.nextSibling); }
    }
  }

  function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

  function determineHeadingSelector() {
    if (contentArea.querySelector('h2')) return 'h2, h3, h4';
    if (contentArea.querySelector('h3')) return 'h3, h4, h5';
    if (contentArea.querySelector('h4')) return 'h4, h5, h6';
    return null;
  }

  // ▼▼▼ NEW: MutationObserver Logic ▼▼▼
  function observeTocContainer(targetNode, containerToHide) {
    console.log('// DEBUG: Creating observer for target:', targetNode, 'Container to hide is:', containerToHide);

    const observer = new MutationObserver((mutationsList, obs) => {
      console.log('// DEBUG: Mutation detected!');
      for (const mutation of mutationsList) {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
          console.log('// DEBUG: Nodes have been added.');
          const tocList = containerToHide.querySelector('.toc-list');
          
          if (tocList) {
            console.log('// DEBUG: Found .toc-list. Checking its children count: ' + tocList.children.length);
            if (tocList.children.length === 0) {
              console.log('// DEBUG: SUCCESS! TOC is empty. Hiding container.', containerToHide);
              containerToHide.style.display = 'none';
            } else {
              console.log('// DEBUG: TOC is NOT empty. Doing nothing.');
            }
            // Once we've checked, we disconnect the observer.
            console.log('// DEBUG: Disconnecting observer.');
            obs.disconnect(); 
            return; // Exit after handling the first valid mutation
          }
        }
      }
    });

    // Start observing the target node for added child nodes
    observer.observe(targetNode, { childList: true });
    console.log('// DEBUG: Observer is now watching.');
  }
  // ▲▲▲ NEW ▲▲▲

  function setupTocbot() {
    tocbot.destroy();
    const headingSelector = determineHeadingSelector();

    if (middleTocContainer) middleTocContainer.style.display = 'none';
    if (rightTocWrapper) rightTocWrapper.style.display = 'none';

    if (!headingSelector) {
      console.log('// DEBUG: No heading selectors found. TOC will not be initialized.');
      return;
    }

    const showMiddleToc = (window.innerWidth < DESKTOP_BREAKPOINT) || forceMiddleToc;

    const tocbotOptions = {
      contentSelector: '.js-toc-content',
      headingSelector: headingSelector,
      hasInnerContainers: true,
      scrollSmooth: true,
      ignoreSelector: '.toc-title, table h1, table h2, table h3, table h4, table h5, table h6, blockquote h1, blockquote h2, blockquote h3, blockquote h4, blockquote h5, blockquote h6'
    };

    if (showMiddleToc) {
      if (middleTocContainer) {
        const tocTarget = middleTocContainer.querySelector('.js-toc-middle');
        if (tocTarget) {
          middleTocContainer.style.display = 'block';
          // Set up the observer BEFORE initializing tocbot
          observeTocContainer(tocTarget, middleTocContainer); 
          tocbot.init({ ...tocbotOptions, tocSelector: '.js-toc-middle', scrollSmoothOffset: -20, headingsOffset: 20 });
        }
      }
    } else if (rightTocWrapper) {
      const tocTarget = rightTocWrapper.querySelector('.js-toc-right');
      if (tocTarget) {
        rightTocWrapper.style.display = 'block';
        // Set up the observer BEFORE initializing tocbot
        observeTocContainer(tocTarget, rightTocWrapper);
        tocbot.init({ ...tocbotOptions, tocSelector: '.js-toc-right', scrollSmoothOffset: -80, headingsOffset: 80 });
      }
    }
  }

  setupTocbot();
  window.addEventListener('resize', debounce(setupTocbot, 150));
});
</script>
{% endif %}