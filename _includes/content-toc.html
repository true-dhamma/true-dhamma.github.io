{%- comment %}
  ============================================================================
  SHARED TOC LOGIC & STYLES
  This file provides all necessary CSS and JS for the Tocbot feature.
  It expects specific HTML containers to be present in the calling layout.
  ============================================================================
{%- endcomment %}

{%- assign show_toc_feature = false -%}
{%- if page.toc == true -%}
  {%- assign show_toc_feature = true -%}
{%- endif -%}

{% if show_toc_feature %}
<style>
  /* --- 基础样式 (移动端优先) --- */
  .content-toc-right-wrapper { display: none; }
  .toc-middle-container { display: none; margin: 2em 0; padding: 1.2em 1.5em; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #f8f9fa; }

  /* --- TOCBOT 通用样式 --- */
  .toc-title { margin: 0 0 1em; font-size: 1.1em; font-weight: 600; color: #333; }
  .toc-middle-container .toc-title { margin-top: 0; }
  .toc-list { margin: 0; padding: 0; list-style: none; }
  .toc-list-item { margin-bottom: 5px; }
  .toc-list .toc-list { padding-left: 1.25em; }
  .toc-link { display: block; padding: 4px 10px; border-left: 2px solid #EEE; color: #777; font-size: 0.875em; line-height: 1.5; transition: all 0.2s ease-in-out; text-decoration: none !important; }
  .toc-link:hover { color: #333; border-left-color: #AAA; }
  .is-active-link { color: #007bff; font-weight: 600; border-left-color: #007bff; background-color: #f0f7ff; }

  /* --- 右侧TOC的Hover效果 --- */
  .content-toc-right-wrapper {
    opacity: 0.5;
    transition: opacity 0.1s ease-in-out;
  }
  .content-toc-right-wrapper:hover { opacity: 1; }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.27.18/tocbot.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const mainContainer = document.querySelector('.main.container');
  const middleTocContainer = document.getElementById('toc-middle-container');
  const rightTocWrapper = document.querySelector('.content-toc-right-wrapper');
  const contentArea = document.querySelector('.js-toc-content');

  if (!contentArea || (!middleTocContainer && !rightTocWrapper)) { return; }

  // ▼▼▼ FINAL ROBUST Universal TOC Placement Logic ▼▼▼
  if (middleTocContainer) {
    let lastHeaderElement = null;
    const headerSelectors = 'h1, h2, h3, .post-meta, blockquote';

    // Iterate through the direct children of the content area to find the end of the header zone
    for (const child of contentArea.children) {
      // Skip the TOC element itself in this check
      if (child.id === 'toc-middle-container') {
        continue;
      }
      
      // If the element is part of our defined "header zone"
      if (child.matches(headerSelectors)) {
        lastHeaderElement = child; // Mark it as the last known header element
      } else {
        // As soon as we find an element that is NOT a header element, the zone ends.
        break;
      }
    }

    // Now, move the TOC container to the correct position
    if (lastHeaderElement) {
      // Insert the TOC after the last found header element
      lastHeaderElement.parentNode.insertBefore(middleTocContainer, lastHeaderElement.nextSibling);
    } else {
      // Fallback: If no header elements were found at all, place TOC at the very top.
      contentArea.prepend(middleTocContainer);
    }
  }
  // ▲▲▲ END: Universal TOC Placement Logic ▲▲▲

  const isDocLayout = mainContainer.classList.contains('layout-doc');
  const DESKTOP_BREAKPOINT = isDocLayout ? 1200 : 1024;
  const pageHasAside = {{ page.aside | default: false }};
  const forceMiddleToc = isDocLayout ? false : pageHasAside;

  function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }

  function determineHeadingSelector() {
    if (contentArea.querySelector('h2')) return 'h2, h3, h4';
    if (contentArea.querySelector('h3')) return 'h3, h4, h5';
    if (contentArea.querySelector('h4')) return 'h4, h5, h6';
    return null;
  }

  function setupTocbot() {
    tocbot.destroy();
    if (middleTocContainer) middleTocContainer.style.display = 'none';
    if (rightTocWrapper) rightTocWrapper.style.display = 'none';

    const headingSelector = determineHeadingSelector();
    if (!headingSelector) { return; }

    const ignoreSelector = '.toc-title, table h1, table h2, table h3, table h4, table h5, table h6, blockquote h1, blockquote h2, blockquote h3, blockquote h4, blockquote h5, blockquote h6';
    const allHeadings = contentArea.querySelectorAll(headingSelector);

    let hasValidHeadings = false;
    for (const heading of allHeadings) {
      if (!heading.matches(ignoreSelector)) {
        hasValidHeadings = true;
        break;
      }
    }

    if (!hasValidHeadings) {
      return;
    }
    
    const showMiddleToc = (window.innerWidth < DESKTOP_BREAKPOINT) || forceMiddleToc;

    const tocbotOptions = {
      contentSelector: '.js-toc-content',
      headingSelector: headingSelector,
      hasInnerContainers: true,
      scrollSmooth: true,
      ignoreSelector: ignoreSelector,
    };
    
    let tocTargetSelector = null;
    let containerToShow = null;

    if (showMiddleToc && middleTocContainer) {
      tocTargetSelector = '.js-toc-middle';
      containerToShow = middleTocContainer;
    } else if (!showMiddleToc && rightTocWrapper) {
      tocTargetSelector = '.js-toc-right';
      containerToShow = rightTocWrapper;
    }

    if (tocTargetSelector && containerToShow) {
      containerToShow.style.display = 'block';
      tocbot.init({ ...tocbotOptions, tocSelector: tocTargetSelector });
    }
  }

  setupTocbot();
  window.addEventListener('resize', debounce(setupTocbot, 150));
});
</script>
{% endif %}