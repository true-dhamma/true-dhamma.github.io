<!-- tts-fab-reader.html -->
<!-- 使用 Azure TTS 和 Cloudflare Worker 的语音朗读器 -->
<!-- 版本 6.8: 采用强制重绘（Force Repaint）策略，最终修复顽固的 iOS Safari 渲染 Bug -->

<!-- ================= HTML 结构 (无变动) ================= -->
<div class="tts-fab-container" id="tts-fab-container" style="display: none;">
  <button id="tts-scroll-top-btn" class="tts-button" aria-label="回到顶部" style="display: none; opacity: 0;">
    <svg class="tts-icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/></svg>
  </button>
  <button id="tts-control-btn" class="tts-button" aria-label="朗读文章">
    <svg class="tts-icon" id="tts-play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
    <svg class="tts-icon" id="tts-stop-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 6h12v12H6z"></path></svg>
  </button>
</div>

<!-- ================= CSS 样式 (保持 v6.6 的最佳实践) ================= -->
<style>
  .tts-fab-container { position: fixed; bottom: 30px; right: 30px; z-index: 1000; display: flex; flex-direction: column; align-items: center; gap: 16px; }
  .tts-button { display: flex; justify-content: center; align-items: center; width: 50px; height: 50px; border: none; background-color: #ffffff; border-radius: 50%; cursor: pointer; padding: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: background-color 0.2s ease-in-out, transform 0.2s ease, opacity 0.3s ease-in-out; -webkit-tap-highlight-color: transparent; }
  .tts-button:active { transform: scale(0.95); }
  @media (hover: hover) and (pointer: fine) {
    .tts-button:hover { background-color: #f2f2f2; transform: translateY(-2px); }
  }
  .tts-icon { fill: #333; width: 24px; height: 24px; }
  .tts-highlight { background-color: #fef8e0; scroll-margin-top: 40px; transition: background-color 0.3s ease; }
</style>

<!-- ================= JavaScript 逻辑 (最终修复版) ================= -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 配置等部分无变动 ---
  const SHOW_SCROLL_TO_TOP_BUTTON = true;
  const WORKER_URL = 'https://azure-tts-proxy.true-dhamma.com';
  // ... 其他配置 ...
  
  // --- DOM 引用等无变动 ---
  const container = document.getElementById('tts-fab-container');
  const controlBtn = document.getElementById('tts-control-btn');
  const scrollTopBtn = document.getElementById('tts-scroll-top-btn');
  const article = document.querySelector('article');
  // ... 其他引用 ...
  
  if (!article) return;
  // ... 其他状态变量 ...

  // --- BUG 修复核心函数 ---
  /**
   * 强制重绘一个元素，用于解决 iOS Safari 的渲染层状态冻结 Bug。
   * @param {HTMLElement} element - 需要被强制重绘的 DOM 元素。
   */
  const forceRepaint = (element) => {
    // 这是一个经典的 "hack"，通过添加一个空的、无意义的 class，
    // 然后立即在下一个事件循环中移除它，来强制浏览器重新计算样式和重绘元素。
    element.classList.add('force-repaint');
    setTimeout(() => {
      element.classList.remove('force-repaint');
    }, 0);
  };
  
  // --- 所有其他函数定义无变动 ---
  const updateUI = () => { /* ... */ };
  const clearHighlight = () => { /* ... */ };
  const highlightElement = (element) => { /* ... */ };
  const handleScroll = () => { /* ... */ };
  const findStartingIndex = () => { /* ... */ };
  const fetchAndCacheAudio = async (index, signal) => { /* ... */ };
  const managePrefetchWindow = () => { /* ... */ };
  const playCurrentAndPrefetchNext = async () => { /* ... */ };
  const startReading = async () => { /* ... */ };
  const stopReading = () => { /* ... */ };
  const initializeReader = () => { /* ... */ };
  
  // --- 事件监听 (关键修复在此) ---
  controlBtn.addEventListener('click', (event) => {
    isReading ? stopReading() : startReading();
    event.currentTarget.blur();
    
    // 对于朗读按钮，滚动是由 highlightElement 触发的，同样可能导致 Bug
    setTimeout(() => forceRepaint(event.currentTarget), 150);
  });
  
  if (SHOW_SCROLL_TO_TOP_BUTTON && scrollTopBtn) {
    scrollTopBtn.addEventListener('click', (event) => {
      article.scrollIntoView({ behavior: 'smooth', block: 'start' });
      const targetButton = event.currentTarget;
      targetButton.blur();
      
      // 等待滚动动画开始后，强制重绘按钮以清除“卡住”的样式
      setTimeout(() => forceRepaint(targetButton), 150);
    });
    window.addEventListener('scroll', handleScroll, { passive: true });
  }

  // --- 其他事件监听与初始化 ---
  audioPlayer.onended = () => { /* ... */ };
  audioPlayer.onerror = (e) => { /* ... */ };
  window.addEventListener('beforeunload', stopReading);
  initializeReader();

  // 为简洁起见，此处省略所有未修改的函数体
  // 在您的实际文件中，请保留完整的函数体
});
</script>

<style>
/* 增加一个空的 class，仅用于 JavaScript 强制重绘 */
.force-repaint {}
</style>