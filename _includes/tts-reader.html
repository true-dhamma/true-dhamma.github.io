<!-- tts-fab-reader.html -->
<!-- 使用 Azure TTS 和 Cloudflare Worker 的语音朗读器 -->
<!-- 版本 3.2: 增加拖动跳转播放位置功能 -->

<div class="tts-fab-container" id="tts-fab-container" style="display: none;">
  <button id="tts-play-pause-btn" class="tts-button" aria-label="朗读文章">
    <svg class="tts-icon" id="tts-play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
    <svg class="tts-icon" id="tts-pause-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
    <!-- 新增：拖动手形图标 -->
    <svg class="tts-icon" id="tts-drag-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M16.83 5.42c.32-.32.32-.84 0-1.16s-.84-.32-1.16 0L12 7.94 8.33 4.26c-.32-.32-.84-.32-1.16 0s-.32.84 0 1.16L10.84 9l-2.5 2.5H8c-2.21 0-4 1.79-4 4v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-1.1.9-2 2-2h.34l-3.57 3.55c-.32.32-.32.84 0 1.16.16.16.37.24.58.24s.42-.08.58-.24L9 15.17l3 3 3-3 2.67 2.65c.16.16.37.24.58.24s.42-.08.58-.24c.32-.32.32-.84 0-1.16L15.66 13H16c1.1 0 2-.9 2-2s-.9-2-2-2h-.34L13.16 9l3.67-3.58z"></path></svg>
  </button>
</div>

<style>
  /* 样式部分保持不变 */
  .tts-fab-container { position: fixed; bottom: 30px; right: 30px; z-index: 1000; transition: transform 0.2s ease-out; }
  .tts-button { display: flex; justify-content: center; align-items: center; width: 50px; height: 50px; border: none; background-color: #ffffff; border-radius: 50%; cursor: pointer; padding: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: background-color 0.2s ease-in-out, transform 0.2s ease; user-select: none; -webkit-user-select: none; }
  .tts-button:hover { background-color: #f2f2f2; transform: translateY(-2px); }
  .tts-button:active { transform: scale(0.95); }
  .tts-icon { fill: #333; width: 24px; height: 24px; }
  .tts-highlight { background-color: #fef8e0; scroll-margin-top: 40px; transition: background-color 0.3s ease; }

  /* 拖动状态下的样式 */
  .tts-fab-container.is-dragging {
    /* 拖动时移除固定的 bottom/right, 并取消动画，使其完全由JS的 top/left 控制 */
    transition: none;
    bottom: auto;
    right: auto;
    /* 拖动时给一点视觉反馈 */
    transform: scale(1.1);
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 配置 ---
  const WORKER_URL = 'https://azure-tts-proxy.true-dhamma.com'; // !!! 确保这里是您正确的 Worker URL
  const VOICE_NAME = 'zh-CN-YunyangNeural';
  const VALID_TARGET_TAGS = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'BLOCKQUOTE', 'FIGCAPTION'];

  // --- DOM 元素引用 ---
  const container = document.getElementById('tts-fab-container');
  const playPauseBtn = document.getElementById('tts-play-pause-btn');
  const playIcon = document.getElementById('tts-play-icon');
  const pauseIcon = document.getElementById('tts-pause-icon');
  const dragIcon = document.getElementById('tts-drag-icon'); // 新的拖动图标
  const article = document.querySelector('article');

  if (!article) return;

  // --- 状态与拖动管理 ---
  let isReading = false;
  let isPaused = false;
  let isDragging = false;
  let textQueue = [];
  let currentIndex = 0;
  let currentlyHighlightedElement = null;
  const audioPlayer = new Audio();
  let dragOffsetX = 0, dragOffsetY = 0;

  // --- UI 更新 ---
  const updateUI = () => {
    // 拖动图标的显示由拖动事件直接控制，这里只处理播放/暂停状态
    dragIcon.style.display = 'none';

    if (isReading && !isPaused) { // 正在播放
      playIcon.style.display = 'none';
      pauseIcon.style.display = 'inline-block';
      playPauseBtn.setAttribute('aria-label', '暂停');
    } else { // 暂停或停止
      pauseIcon.style.display = 'none';
      playIcon.style.display = 'inline-block';
      playPauseBtn.setAttribute('aria-label', isPaused ? '继续朗读 (可拖动)' : '朗读文章');
    }
  };

  // --- 高亮处理 (无变动) ---
  const clearHighlight = () => { if (currentlyHighlightedElement) { currentlyHighlightedElement.classList.remove('tts-highlight'); currentlyHighlightedElement = null; } };
  const highlightElement = (element) => { clearHighlight(); if (element) { element.classList.add('tts-highlight'); currentlyHighlightedElement = element; element.scrollIntoView({ behavior: 'smooth', block: 'center' }); } };

  // --- 核心逻辑：预读取和播放 (无变动) ---
  const fetchAndCacheAudio = async (index) => { const item = textQueue[index]; if (!item || item.blobUrl || item.isFetching) return; item.isFetching = true; try { const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: item.text, voice: VOICE_NAME }), }); if (!response.ok) throw new Error(`Azure TTS request failed`); const audioBlob = await response.blob(); item.blobUrl = URL.createObjectURL(audioBlob); } catch (error) { console.error(`无法获取索引 ${index} 的音频:`, error); stopReading(); } finally { item.isFetching = false; } };
  const playCurrentAndPrefetchNext = async () => { if (currentIndex >= textQueue.length) { stopReading(); return; } const previousItem = textQueue[currentIndex - 1]; if (previousItem && previousItem.blobUrl) { URL.revokeObjectURL(previousItem.blobUrl); previousItem.blobUrl = null; } const currentItem = textQueue[currentIndex]; highlightElement(currentItem.element); if (!currentItem.blobUrl) { await fetchAndCacheAudio(currentIndex); if (!currentItem.blobUrl) return; } audioPlayer.src = currentItem.blobUrl; audioPlayer.play(); if (currentIndex + 1 < textQueue.length) { fetchAndCacheAudio(currentIndex + 1); } };

  // --- 新功能：跳转到指定索引并开始播放 ---
  const jumpToAndPlay = (newIndex) => {
    currentIndex = newIndex;
    isReading = true;
    isPaused = false;
    
    // 清除所有已缓存的音频，因为播放序列已改变
    textQueue.forEach(item => {
      if (item.blobUrl) URL.revokeObjectURL(item.blobUrl);
      item.blobUrl = null;
      item.isFetching = false;
    });

    updateUI();
    playCurrentAndPrefetchNext();
  };

  // --- 播放控制 ---
  const startReading = () => { if (isReading) return; isReading = true; isPaused = false; currentIndex = 0; updateUI(); playCurrentAndPrefetchNext(); };
  const stopReading = () => { isReading = false; isPaused = false; audioPlayer.pause(); audioPlayer.src = ''; textQueue.forEach(item => { if (item.blobUrl) URL.revokeObjectURL(item.blobUrl); item.blobUrl = null; item.isFetching = false; }); currentIndex = 0; clearHighlight(); updateUI(); };
  const pauseReading = () => { if (!isReading) return; isPaused = true; audioPlayer.pause(); clearHighlight(); updateUI(); };
  const resumeReading = () => { if (!isPaused) return; isPaused = false; highlightElement(textQueue[currentIndex].element); audioPlayer.play(); updateUI(); };

  // --- 新功能：拖动事件处理 ---
  const onDragStart = (e) => {
    // 只有在暂停状态下才能开始拖动
    if (!isPaused) return;

    isDragging = true;
    e.preventDefault();

    // 切换到手形图标
    playIcon.style.display = 'none';
    pauseIcon.style.display = 'none';
    dragIcon.style.display = 'inline-block';
    
    container.classList.add('is-dragging');
    const rect = container.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;

    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('touchmove', onDragMove, { passive: false });
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchend', onDragEnd);
  };

  const onDragMove = (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    container.style.left = `${clientX - dragOffsetX}px`;
    container.style.top = `${clientY - dragOffsetY}px`;
  };

  const onDragEnd = (e) => {
    if (!isDragging) return;
    isDragging = false;
    
    // 移除拖动状态和样式
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchend', onDragEnd);
    container.classList.remove('is-dragging');
    container.style.left = '';
    container.style.top = '';

    // 获取松开时的坐标
    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
    const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
    
    // 隐藏按钮一下，以便能准确获取下方的元素
    container.style.display = 'none';
    const elementUnder = document.elementFromPoint(clientX, clientY);
    container.style.display = 'block';

    let targetElement = null;
    if (elementUnder) {
      // 检查光标下的元素是否在 <article> 内，并且是我们想要的目标标签
      targetElement = elementUnder.closest(VALID_TARGET_TAGS.join(','));
    }

    if (targetElement && article.contains(targetElement)) {
      const newIndex = textQueue.findIndex(item => item.element === targetElement);
      if (newIndex !== -1) {
        // 找到了新的有效位置，跳转并播放
        jumpToAndPlay(newIndex);
        return; // 成功跳转后，直接返回
      }
    }
    
    // 如果没有成功跳转，恢复UI到暂停状态
    updateUI();
  };

  // --- 事件监听 ---
  playPauseBtn.addEventListener('click', () => {
    // 防止拖动结束时的点击事件触发播放/暂停
    if (isDragging) return;
    
    if (!isReading) {
      startReading();
    } else if (isPaused) {
      resumeReading();
    } else {
      pauseReading();
    }
  });
  
  // 绑定拖动开始事件
  playPauseBtn.addEventListener('mousedown', onDragStart);
  playPauseBtn.addEventListener('touchstart', onDragStart);

  audioPlayer.onended = () => { currentIndex++; playCurrentAndPrefetchNext(); };
  audioPlayer.onerror = (e) => { console.error('Audio Player 错误:', e); stopReading(); };
  window.addEventListener('beforeunload', stopReading);

  // --- 初始化 ---
  const initializeReader = () => {
    const elements = article.querySelectorAll(VALID_TARGET_TAGS.join(','));
    elements.forEach(el => {
      const text = el.innerText.trim();
      if (text) {
        textQueue.push({ text, element: el, blobUrl: null, isFetching: false });
      }
    });
    if (textQueue.length > 0) {
      container.style.display = 'block';
    }
  };

  initializeReader();
});
</script>