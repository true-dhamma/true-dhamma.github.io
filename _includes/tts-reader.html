<!-- tts-fab-reader.html -->
<!-- 使用 Azure TTS 和 Cloudflare Worker 的语音朗读器 -->
<!-- 版本 4.0: 智能播放起点, 简化的播放/停止控制, 严格的资源管理 -->

<div class="tts-fab-container" id="tts-fab-container" style="display: none;">
  <!-- 按钮现在只负责播放和停止 -->
  <button id="tts-control-btn" class="tts-button" aria-label="朗读文章">
    <svg class="tts-icon" id="tts-play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
    <!-- 此图标现在代表“停止” -->
    <svg class="tts-icon" id="tts-stop-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 6h12v12H6z"></path></svg>
  </button>
</div>

<style>
  /* 样式部分保持不变 */
  .tts-fab-container { position: fixed; bottom: 30px; right: 30px; z-index: 1000; }
  .tts-button { display: flex; justify-content: center; align-items: center; width: 50px; height: 50px; border: none; background-color: #ffffff; border-radius: 50%; cursor: pointer; padding: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: background-color 0.2s ease-in-out, transform 0.2s ease; }
  .tts-button:hover { background-color: #f2f2f2; transform: translateY(-2px); }
  .tts-button:active { transform: scale(0.95); }
  .tts-icon { fill: #333; width: 24px; height: 24px; }
  .tts-highlight { background-color: #fef8e0; scroll-margin-top: 40px; transition: background-color 0.3s ease; }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 配置 ---
  const WORKER_URL = 'https://azure-tts-proxy.true-dhamma.com'; // 已更新为指定地址
  const VOICE_NAME = 'zh-CN-YunyangNeural'; // 'zh-CN-YunyangNeural' 或 'zh-CN-XiaoxiaoNeural'

  // --- DOM 元素引用 ---
  const container = document.getElementById('tts-fab-container');
  const controlBtn = document.getElementById('tts-control-btn');
  const playIcon = document.getElementById('tts-play-icon');
  const stopIcon = document.getElementById('tts-stop-icon'); // 对应新的停止图标
  const article = document.querySelector('article');

  if (!article) return;

  // --- 状态管理 ---
  let isReading = false; // 唯一的播放状态
  let textQueue = []; // 存储 { text, element, blobUrl, isFetching }
  let currentIndex = 0;
  let currentlyHighlightedElement = null;
  const audioPlayer = new Audio();

  // --- UI 更新 ---
  const updateUI = () => {
    if (isReading) {
      playIcon.style.display = 'none';
      stopIcon.style.display = 'inline-block';
      controlBtn.setAttribute('aria-label', '停止朗读');
    } else {
      playIcon.style.display = 'inline-block';
      stopIcon.style.display = 'none';
      controlBtn.setAttribute('aria-label', '朗读文章');
    }
  };

  // --- 高亮处理 (无变动) ---
  const clearHighlight = () => {
    if (currentlyHighlightedElement) {
      currentlyHighlightedElement.classList.remove('tts-highlight');
      currentlyHighlightedElement = null;
    }
  };
  const highlightElement = (element) => {
    clearHighlight();
    if (element) {
      element.classList.add('tts-highlight');
      currentlyHighlightedElement = element;
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  };

  // --- 核心功能函数 ---

  /**
   * 使用 IntersectionObserver API 找到屏幕上第一个可见的段落索引。
   * 这是现代、高效的方式，避免了在滚动时频繁计算。
   * @returns {Promise<number>} 返回一个解析为起始索引的 Promise。
   */
  const findStartingIndex = () => {
    return new Promise(resolve => {
      const elements = textQueue.map(item => item.element);
      
      const observer = new IntersectionObserver(entries => {
        let firstVisibleElement = null;
        let minTop = Infinity;

        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const top = entry.boundingClientRect.top;
            if (top < minTop) {
              minTop = top;
              firstVisibleElement = entry.target;
            }
          }
        });
        
        // 结束观察，避免不必要的性能开销
        observer.disconnect();

        if (firstVisibleElement) {
          const foundIndex = elements.findIndex(el => el === firstVisibleElement);
          resolve(foundIndex > -1 ? foundIndex : 0);
        } else {
          // 如果 <article> 内没有任何元素可见，则从头开始
          resolve(0);
        }
      }, {
        // rootMargin: '0px 0px -50% 0px' // 可选：调整触发区域，例如只考虑屏幕上半部分
        threshold: 0.01 // 元素露出一点点就算可见
      });

      elements.forEach(el => observer.observe(el));
    });
  };

  const fetchAndCacheAudio = async (index) => {
    const item = textQueue[index];
    if (!item || item.blobUrl || item.isFetching) return;

    item.isFetching = true;
    try {
      const response = await fetch(WORKER_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: item.text, voice: VOICE_NAME }),
      });

      if (!response.ok) throw new Error(`Azure TTS request failed: ${response.status}`);
      
      const audioBlob = await response.blob();
      item.blobUrl = URL.createObjectURL(audioBlob);
    } catch (error) {
      console.error(`无法获取索引 ${index} 的音频:`, error);
      if (isReading) stopReading();
    } finally {
      item.isFetching = false;
    }
  };

  const playCurrentAndPrefetchNext = async () => {
    if (currentIndex >= textQueue.length || !isReading) {
      stopReading();
      return;
    }
    
    // 释放上一个音频对象的内存
    const previousItem = textQueue[currentIndex - 1];
    if (previousItem && previousItem.blobUrl) {
      URL.revokeObjectURL(previousItem.blobUrl);
      previousItem.blobUrl = null;
    }

    const currentItem = textQueue[currentIndex];
    highlightElement(currentItem.element);

    if (!currentItem.blobUrl) {
      await fetchAndCacheAudio(currentIndex);
      if (!currentItem.blobUrl) return; // 获取失败则停止
    }

    // 再次检查状态，因为音频获取可能是异步的
    if (!isReading) {
        stopReading();
        return;
    }

    audioPlayer.src = currentItem.blobUrl;
    audioPlayer.play();

    if (currentIndex + 1 < textQueue.length) {
      fetchAndCacheAudio(currentIndex + 1);
    }
  };

  // --- 控制函数 ---

  /**
   * 开始朗读。会先确定起点，然后启动播放流程。
   */
  const startReading = async () => {
    if (isReading) return;
    isReading = true;
    
    updateUI();
    
    currentIndex = await findStartingIndex();
    playCurrentAndPrefetchNext();
  };

  /**
   * 停止朗读并清理所有资源。
   * 这是唯一的停止/重置函数，确保彻底清理。
   */
  const stopReading = () => {
    isReading = false;
    
    audioPlayer.pause();
    audioPlayer.src = '';

    // 关键：清理所有已缓存的 blob URL，彻底释放内存
    textQueue.forEach(item => {
      if (item.blobUrl) {
        URL.revokeObjectURL(item.blobUrl);
      }
      // 重置队列状态，为下次播放做准备
      item.blobUrl = null;
      item.isFetching = false;
    });
    
    currentIndex = 0;
    clearHighlight();
    updateUI();
  };

  // --- 事件监听 ---
  controlBtn.addEventListener('click', () => {
    // 逻辑简化为播放和停止的切换
    if (isReading) {
      stopReading();
    } else {
      startReading();
    }
  });

  audioPlayer.onended = () => {
    if (isReading) {
      currentIndex++;
      playCurrentAndPrefetchNext();
    }
  };
  
  audioPlayer.onerror = (e) => {
    console.error('Audio Player 发生错误:', e);
    stopReading();
  };

  window.addEventListener('beforeunload', stopReading);

  // --- 初始化 ---
  const initializeReader = () => {
    const elements = article.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, figcaption');
    elements.forEach(el => {
      const text = el.innerText.trim();
      if (text) {
        textQueue.push({ text: text, element: el, blobUrl: null, isFetching: false });
      }
    });

    if (textQueue.length > 0) {
      container.style.display = 'block';
    }
  };

  initializeReader();
});
</script>