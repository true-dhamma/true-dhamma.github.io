<!-- tts-fab-reader.html -->
<!-- 使用 Azure TTS 和 Cloudflare Worker 的语音朗读器 -->
<!-- 版本 5.0: 支持5条预读取队列、失败自动重试、并使用 AbortController 确保即时停止 -->

<div class="tts-fab-container" id="tts-fab-container" style="display: none;">
  <button id="tts-control-btn" class="tts-button" aria-label="朗读文章">
    <svg class="tts-icon" id="tts-play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
    <svg class="tts-icon" id="tts-stop-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 6h12v12H6z"></path></svg>
  </button>
</div>

<style>
  /* 样式部分保持不变 */
  .tts-fab-container { position: fixed; bottom: 30px; right: 30px; z-index: 1000; }
  .tts-button { display: flex; justify-content: center; align-items: center; width: 50px; height: 50px; border: none; background-color: #ffffff; border-radius: 50%; cursor: pointer; padding: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: background-color 0.2s ease-in-out, transform 0.2s ease; }
  .tts-button:hover { background-color: #f2f2f2; transform: translateY(-2px); }
  .tts-button:active { transform: scale(0.95); }
  .tts-icon { fill: #333; width: 24px; height: 24px; }
  .tts-highlight { background-color: #fef8e0; scroll-margin-top: 40px; transition: background-color 0.3s ease; }
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 配置 ---
  const WORKER_URL = 'https://azure-tts-proxy.true-dhamma.com';
  const VOICE_NAME = 'zh-CN-YunyangNeural';
  const PREFETCH_WINDOW_SIZE = 5; // 预读取队列的大小
  const MAX_RETRIES = 3; // 下载失败后的最大重试次数
  const RETRY_DELAY = 1000; // 重试前的等待时间 (毫秒)

  // --- DOM 元素引用 ---
  const container = document.getElementById('tts-fab-container');
  const controlBtn = document.getElementById('tts-control-btn');
  const playIcon = document.getElementById('tts-play-icon');
  const stopIcon = document.getElementById('tts-stop-icon');
  const article = document.querySelector('article');

  if (!article) return;

  // --- 状态管理 ---
  let isReading = false;
  let textQueue = [];
  let currentIndex = 0;
  let currentlyHighlightedElement = null;
  const audioPlayer = new Audio();
  let fetchController; // 用于中止所有 fetch 请求的控制器

  // --- UI 和高亮处理 (无变动) ---
  const updateUI = () => { /* ... (代码同前) ... */ };
  const clearHighlight = () => { /* ... (代码同前) ... */ };
  const highlightElement = (element) => { /* ... (代码同前) ... */ };
  
  updateUI = () => { if (isReading) { playIcon.style.display = 'none'; stopIcon.style.display = 'inline-block'; controlBtn.setAttribute('aria-label', '停止朗读'); } else { playIcon.style.display = 'inline-block'; stopIcon.style.display = 'none'; controlBtn.setAttribute('aria-label', '朗读文章'); } };
  clearHighlight = () => { if (currentlyHighlightedElement) { currentlyHighlightedElement.classList.remove('tts-highlight'); currentlyHighlightedElement = null; } };
  highlightElement = (element) => { clearHighlight(); if (element) { element.classList.add('tts-highlight'); currentlyHighlightedElement = element; element.scrollIntoView({ behavior: 'smooth', block: 'center' }); } };


  // --- 核心功能函数 ---
  
  const findStartingIndex = () => {
    return new Promise(resolve => {
      const elements = textQueue.map(item => item.element);
      const observer = new IntersectionObserver(entries => {
        let firstVisibleElement = null; let minTop = Infinity;
        entries.forEach(entry => { if (entry.isIntersecting) { const top = entry.boundingClientRect.top; if (top < minTop) { minTop = top; firstVisibleElement = entry.target; } } });
        observer.disconnect();
        const foundIndex = firstVisibleElement ? elements.findIndex(el => el === firstVisibleElement) : -1;
        resolve(foundIndex > -1 ? foundIndex : 0);
      }, { threshold: 0.01 });
      elements.forEach(el => observer.observe(el));
    });
  };

  /**
   * 下载并缓存指定索引的音频，支持重试和中止。
   * @param {number} index - 要下载的音频在队列中的索引。
   * @param {AbortSignal} signal - 用于中止 fetch 请求的信号。
   * @returns {Promise<boolean>} - 返回一个 Promise，成功时解析为 true，失败或被中止时解析为 false。
   */
  const fetchAndCacheAudio = async (index, signal) => {
    const item = textQueue[index];
    if (!item || item.blobUrl || item.isFetching) return true; // 已存在或正在获取，视为成功

    item.isFetching = true;
    let success = false;
    for (let i = 0; i < MAX_RETRIES; i++) {
      // 循环开始时检查是否已停止
      if (!isReading || signal.aborted) {
        item.isFetching = false;
        return false;
      }
      try {
        const response = await fetch(WORKER_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: item.text, voice: VOICE_NAME }),
          signal: signal, // 将中止信号传递给 fetch
        });
        if (!response.ok) throw new Error(`Request failed with status ${response.status}`);
        const audioBlob = await response.blob();
        item.blobUrl = URL.createObjectURL(audioBlob);
        success = true;
        break; // 成功则跳出重试循环
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log(`Fetch for index ${index} was aborted.`);
          break; // 中止是正常操作，直接跳出循环
        }
        console.warn(`Failed to fetch index ${index} (Attempt ${i + 1}/${MAX_RETRIES}):`, error.message);
        if (i < MAX_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
        }
      }
    }
    item.isFetching = false;
    return success;
  };

  /**
   * 管理预读取窗口，确保当前播放点之后的 N 个音频已开始下载。
   */
  const managePrefetchWindow = () => {
    const start = currentIndex + 1;
    const end = Math.min(currentIndex + PREFETCH_WINDOW_SIZE + 1, textQueue.length);
    for (let i = start; i < end; i++) {
        // 异步执行，不阻塞主流程
        fetchAndCacheAudio(i, fetchController.signal);
    }
  };
  
  const playCurrentAndPrefetchNext = async () => {
    if (currentIndex >= textQueue.length || !isReading) {
      if (isReading) stopReading();
      return;
    }

    const previousItem = textQueue[currentIndex - 1];
    if (previousItem && previousItem.blobUrl) {
      URL.revokeObjectURL(previousItem.blobUrl);
      previousItem.blobUrl = null;
    }

    const currentItem = textQueue[currentIndex];
    highlightElement(currentItem.element);

    // 如果当前音频未缓存，则等待它下载完成
    const success = await fetchAndCacheAudio(currentIndex, fetchController.signal);
    
    // 再次检查状态，确保在下载过程中用户没有点击停止
    if (!isReading || !success) {
      if(isReading) stopReading(); // 如果是下载失败导致的，则停止
      return;
    }

    audioPlayer.src = currentItem.blobUrl;
    audioPlayer.play().catch(err => {
        console.error("Audio playback failed:", err);
        if(isReading) stopReading();
    });

    // 播放当前的同时，管理预读取窗口
    managePrefetchWindow();
  };

  // --- 控制函数 ---

  const startReading = async () => {
    if (isReading) return;
    isReading = true;
    fetchController = new AbortController(); // 为本次播放会话创建新的控制器
    updateUI();
    currentIndex = await findStartingIndex();
    playCurrentAndPrefetchNext();
  };

  const stopReading = () => {
    if (!isReading && !fetchController) return; // 如果已经停止，则无需操作
    isReading = false;
    
    if (fetchController) {
      fetchController.abort(); // 关键：中止所有进行中的 fetch 请求
      fetchController = null;
    }
    
    audioPlayer.pause();
    audioPlayer.src = '';

    textQueue.forEach(item => {
      if (item.blobUrl) URL.revokeObjectURL(item.blobUrl);
      item.blobUrl = null;
      item.isFetching = false;
    });
    
    currentIndex = 0;
    clearHighlight();
    updateUI();
  };

  // --- 事件监听 ---
  controlBtn.addEventListener('click', () => { isReading ? stopReading() : startReading(); });
  audioPlayer.onended = () => { if (isReading) { currentIndex++; playCurrentAndPrefetchNext(); } };
  audioPlayer.onerror = (e) => { if (isReading) { console.error('Audio Player 错误:', e); stopReading(); } };
  window.addEventListener('beforeunload', stopReading);

  // --- 初始化 (无变动) ---
  const initializeReader = () => {
    const elements = article.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, blockquote, figcaption');
    elements.forEach(el => {
      const text = el.innerText.trim();
      if (text) textQueue.push({ text: text, element: el, blobUrl: null, isFetching: false });
    });
    if (textQueue.length > 0) container.style.display = 'block';
  };

  initializeReader();
});
</script>