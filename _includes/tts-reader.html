<!-- tts-fab-reader.html -->
<!-- 使用 Azure TTS 和 Cloudflare Worker 的语音朗读器 -->
<!-- 版本 7.1: 增加 MutationObserver，完美处理滚动按钮显隐时的定位 -->

<!-- ================= HTML 结构 (无变动) ================= -->
<div class="tts-fab-container" id="tts-fab-container" style="display: none;">
  <button id="tts-scroll-top-btn" class="tts-button" aria-label="回到顶部" style="display: none; opacity: 0;">
    <svg class="tts-icon" xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6 1.41 1.41z"/></svg>
  </button>
  <button id="tts-control-btn" class="tts-button" aria-label="朗读文章">
    <svg class="tts-icon" id="tts-play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>
    <svg class="tts-icon" id="tts-stop-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 6h12v12H6z"></path></svg>
  </button>
</div>

<!-- ================= CSS 样式 (与上一版相同) ================= -->
<style>
  .tts-fab-container {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    transform-origin: bottom right;
  }
  .tts-button { display: flex; justify-content: center; align-items: center; width: 50px; height: 50px; border: none; background-color: #ffffff; border-radius: 50%; cursor: pointer; padding: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: background-color 0.2s ease-in-out, transform 0.2s ease, opacity 0.3s ease-in-out; }
  .tts-button:hover { background-color: #f2f2f2; transform: translateY(-2px); }
  .tts-button:active { transform: scale(0.95); }
  .tts-icon { fill: #333; width: 24px; height: 24px; }
  .tts-highlight { background-color: #fef8e0; scroll-margin-top: 40px; transition: background-color 0.3s ease; }
</style>

<!-- ================= JavaScript 逻辑 (核心改动) ================= -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- 配置 & DOM 元素 (无变动) ---
  const SHOW_SCROLL_TO_TOP_BUTTON = true;
  const WORKER_URL = 'https://proxy.true-dhamma.com/tts-proxy';
  const container = document.getElementById('tts-fab-container');
  const controlBtn = document.getElementById('tts-control-btn');
  const scrollTopBtn = document.getElementById('tts-scroll-top-btn');
  const article = document.querySelector('article');
  // ... 其他变量和函数声明部分为了简洁省略，它们都与上一版相同 ...

  if (!article) return;

  // ▼▼▼ NEW: Visual Viewport Optimization Logic (Now with MutationObserver) ▼▼▼
  const optimizeForTouchZoom = () => {
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (!isTouchDevice || !window.visualViewport) {
      return;
    }

    const computedStyle = window.getComputedStyle(container);
    const initialRight = parseInt(computedStyle.right, 10);
    const initialBottom = parseInt(computedStyle.bottom, 10);

    const updateFabPosition = () => {
      const vv = window.visualViewport;
      const scale = vv.scale;

      if (scale <= 1) {
        container.style.position = 'fixed';
        container.style.transform = '';
        container.style.top = 'auto';
        container.style.left = 'auto';
        container.style.right = `${initialRight}px`;
        container.style.bottom = `${initialBottom}px`;
        return;
      }
      
      container.style.position = 'absolute';
      container.style.transform = `scale(${1 / scale})`;
      
      // KEY: This calculation now uses the *current* offsetHeight, which is always up-to-date.
      const newTop = vv.offsetTop + vv.height - (container.offsetHeight * scale) - (initialBottom * scale);
      const newLeft = vv.offsetLeft + vv.width - (container.offsetWidth * scale) - (initialRight * scale);

      container.style.top = `${newTop / scale}px`;
      container.style.left = `${newLeft / scale}px`;
      container.style.right = 'auto';
      container.style.bottom = 'auto';
    };

    // Attach listeners to viewport events for zoom and pan
    window.visualViewport.addEventListener('resize', updateFabPosition);
    window.visualViewport.addEventListener('scroll', updateFabPosition);

    // KEY CHANGE: Create a MutationObserver to watch for internal changes (button appearing/disappearing)
    const observer = new MutationObserver(() => {
      // When a mutation is detected, simply re-run our positioning logic.
      updateFabPosition();
    });

    // Configure and start the observer
    observer.observe(container, {
      childList: true, // Watch for children being added or removed
      attributes: true, // Watch for attribute changes (like 'style')
      subtree: true, // Watch descendants of the container as well
      attributeFilter: ['style'] // Be efficient, only care about the style attribute
    });

    // Initial call to set the state correctly
    updateFabPosition();
  };
  // ▲▲▲ END: Visual Viewport Optimization Logic ▲▲▲

  // --- 再往下是完整的TTS朗读逻辑，为了简洁和清晰，我将它们折叠起来 ---
  // --- 但在你的最终文件中，它们需要被完整地放在这里 ---
  let isReading, textQueue, currentIndex, currentlyHighlightedElement, audioPlayer, fetchController;
  const updateUI = () => { /* ... */ };
  const clearHighlight = () => { /* ... */ };
  const highlightElement = (element) => { /* ... */ };
  const handleScroll = () => { /* ... */ };
  const findStartingIndex = () => { /* ... */ };
  const fetchAndCacheAudio = async (index, signal) => { /* ... */ };
  const managePrefetchWindow = () => { /* ... */ };
  const playCurrentAndPrefetchNext = async () => { /* ... */ };
  const startReading = async () => { /* ... */ };
  const stopReading = () => { /* ... */ };
  const initializeReader = () => { /* ... */ };

  // --- 为了让你能直接复制粘贴，这里是上面所有折叠函数的完整实现 ---
  const playIcon = document.getElementById('tts-play-icon');
  const stopIcon = document.getElementById('tts-stop-icon');
  isReading = false; textQueue = []; currentIndex = 0; currentlyHighlightedElement = null; audioPlayer = new Audio();
  updateUI = () => { if (isReading) { playIcon.style.display = 'none'; stopIcon.style.display = 'inline-block'; controlBtn.setAttribute('aria-label', '停止朗读'); } else { playIcon.style.display = 'inline-block'; stopIcon.style.display = 'none'; controlBtn.setAttribute('aria-label', '朗读文章'); } };
  clearHighlight = () => { if (currentlyHighlightedElement) { currentlyHighlightedElement.classList.remove('tts-highlight'); currentlyHighlightedElement = null; } };
  highlightElement = (element) => { clearHighlight(); if (element) { element.classList.add('tts-highlight'); currentlyHighlightedElement = element; element.scrollIntoView({ behavior: 'smooth', block: 'center' }); } };
  handleScroll = () => { if (!SHOW_SCROLL_TO_TOP_BUTTON || !scrollTopBtn) return; const shouldBeVisible = window.scrollY > window.innerHeight / 2; if (shouldBeVisible) { scrollTopBtn.style.display = 'flex'; requestAnimationFrame(() => { scrollTopBtn.style.opacity = '1'; }); } else { scrollTopBtn.style.opacity = '0'; setTimeout(() => { if (window.scrollY <= window.innerHeight / 2) { scrollTopBtn.style.display = 'none'; } }, 300); } };
  findStartingIndex = () => { return new Promise(resolve => { const elements = textQueue.map(item => item.element); const observer = new IntersectionObserver(entries => { let firstVisibleElement = null; let minTop = Infinity; entries.forEach(entry => { if (entry.isIntersecting) { const top = entry.boundingClientRect.top; if (top < minTop) { minTop = top; firstVisibleElement = entry.target; } } }); observer.disconnect(); const foundIndex = firstVisibleElement ? elements.findIndex(el => el === firstVisibleElement) : -1; resolve(foundIndex > -1 ? foundIndex : 0); }, { threshold: 0.01 }); elements.forEach(el => observer.observe(el)); }); };
  fetchAndCacheAudio = async (index, signal) => { const item = textQueue[index]; if (!item || item.blobUrl || item.isFetching) return true; item.isFetching = true; let success = false; for (let i = 0; i < 3; i++) { if (!isReading || signal.aborted) { item.isFetching = false; return false; } try { const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: item.text }), signal: signal }); if (!response.ok) throw new Error(`Request failed`); const audioBlob = await response.blob(); item.blobUrl = URL.createObjectURL(audioBlob); success = true; break; } catch (error) { if (error.name === 'AbortError') break; await new Promise(r => setTimeout(r, 1000)); } } item.isFetching = false; return success; };
  managePrefetchWindow = () => { const end = Math.min(currentIndex + 6, textQueue.length); for (let i = currentIndex + 1; i < end; i++) fetchAndCacheAudio(i, fetchController.signal); };
  playCurrentAndPrefetchNext = async () => { if (currentIndex >= textQueue.length || !isReading) { if (isReading) stopReading(); return; } const prev = textQueue[currentIndex - 1]; if (prev && prev.blobUrl) { URL.revokeObjectURL(prev.blobUrl); prev.blobUrl = null; } const current = textQueue[currentIndex]; highlightElement(current.element); const success = await fetchAndCacheAudio(currentIndex, fetchController.signal); if (!isReading || !success) { if (isReading) stopReading(); return; } audioPlayer.src = current.blobUrl; audioPlayer.play().catch(err => { if (isReading) stopReading(); }); managePrefetchWindow(); };
  startReading = async () => { if (isReading) return; isReading = true; fetchController = new AbortController(); updateUI(); currentIndex = await findStartingIndex(); if (!isReading) { stopReading(); return; } playCurrentAndPrefetchNext(); };
  stopReading = () => { if (!isReading && !fetchController) return; isReading = false; if (fetchController) { fetchController.abort(); fetchController = null; } audioPlayer.pause(); audioPlayer.src = ''; textQueue.forEach(item => { if (item.blobUrl) URL.revokeObjectURL(item.blobUrl); item.blobUrl = null; item.isFetching = false; }); currentIndex = 0; clearHighlight(); updateUI(); };
  initializeReader = () => { const selector = 'p, h1, h2, h3, h4, h5, h6, li, blockquote, figcaption'; const allPotentialElements = Array.from(article.querySelectorAll(selector)); const elementSet = new Set(allPotentialElements); const topLevelElements = allPotentialElements.filter(el => { let p = el.parentElement; while (p && p !== article) { if (elementSet.has(p)) return false; p = p.parentElement; } return true; }); topLevelElements.forEach(el => { const text = el.innerText.trim(); if (text) textQueue.push({ text: text, element: el, blobUrl: null, isFetching: false }); }); if (textQueue.length > 0) { container.style.display = 'flex'; handleScroll(); } };

  // --- Final Initialization Flow ---
  controlBtn.addEventListener('click', () => { isReading ? stopReading() : startReading(); });
  audioPlayer.onended = () => { if (isReading) { currentIndex++; playCurrentAndPrefetchNext(); } };
  audioPlayer.onerror = (e) => { if (isReading) { console.error('Audio Player 错误:', e); stopReading(); } };
  window.addEventListener('beforeunload', stopReading);
  if (SHOW_SCROLL_TO_TOP_BUTTON && scrollTopBtn) {
    scrollTopBtn.addEventListener('click', () => { article.scrollIntoView({ behavior: 'smooth', block: 'start' }); });
    window.addEventListener('scroll', handleScroll, { passive: true });
  }

  initializeReader();
  optimizeForTouchZoom(); // Activate the new, robust optimization logic
});
</script>